#cloud-config
package_update: true
package_upgrade: true

packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg
  - lsb-release
  - software-properties-common
  - jq
  - unzip

write_files:
  - path: /opt/nginx/default.conf
    content: |
      server {
          listen 80 default_server;
          server_name _;
          
          # Health check endpoint
          location /health {
              access_log off;
              return 200 "healthy\n";
              add_header Content-Type text/plain;
          }
          
          # Default response
          location / {
              return 200 "Nginx reverse proxy is running. Configure services in /opt/nginx/conf.d/\n";
              add_header Content-Type text/plain;
          }
      }
    permissions: '0644'
  
  - path: /opt/nginx/README.md
    content: |
      # Nginx Reverse Proxy Configuration
      
      This Nginx instance runs as a Docker container and acts as a reverse proxy
      for applications deployed on the docker network.
      
      ## Network Architecture
      
      - Public Internet → VM Public IP → Nginx Container (ports 80/443)
      - Nginx → Docker Network (app-network) → Application Containers
      
      ## Adding New Services
      
      Create a new .conf file in `/opt/nginx/conf.d/` for each service:
      
      **Example: Proxying to a backend service**
      ```nginx
      server {
          listen 80;
          server_name api.example.com;
          
          location / {
              resolver 127.0.0.11 valid=30s;
              set $backend "http://backend-service:8080";
              proxy_pass $backend;
              
              # Headers
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
              
              # Timeouts
              proxy_connect_timeout 60s;
              proxy_send_timeout 60s;
              proxy_read_timeout 60s;
          }
      }
      ```
      
      **Example: Load balancing**
      ```nginx
      upstream backend_cluster {
          server backend1:8080;
          server backend2:8080;
          server backend3:8080;
      }
      
      server {
          listen 80;
          server_name app.example.com;
          
          location / {
              proxy_pass http://backend_cluster;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
          }
      }
      ```
      
      ## Deploying Applications
      
      1. Deploy your application container to the app-network:
         ```bash
         docker run -d \
           --name my-app \
           --network app-network \
           -p 8080:8080 \
           my-app:latest
         ```
      
      2. Create Nginx configuration:
         ```bash
         cat > /opt/nginx/conf.d/my-app.conf <<EOF
         server {
             listen 80;
             server_name myapp.example.com;
             
             location / {
                 proxy_pass http://my-app:8080;
                 proxy_set_header Host \$host;
                 proxy_set_header X-Real-IP \$remote_addr;
             }
         }
         EOF
         ```
      
      3. Reload Nginx:
         ```bash
         docker exec nginx nginx -s reload
         ```
      
      4. Access your application:
         - Via public IP: http://VM_PUBLIC_IP
         - Via domain: http://myapp.example.com (configure DNS)
      
      ## Using Docker Compose
      
      Create docker-compose.yml:
      ```yaml
      version: '3.8'
      
      services:
        backend:
          image: my-backend:latest
          networks:
            - app-network
          environment:
            - DB_HOST=postgres
            - DB_PORT=5432
        
        postgres:
          image: postgres:15
          networks:
            - app-network
          volumes:
            - postgres-data:/var/lib/postgresql/data
          environment:
            - POSTGRES_PASSWORD=secret
      
      networks:
        app-network:
          external: true
      
      volumes:
        postgres-data:
      ```
      
      Deploy with docker compose:
      ```bash
      docker compose up -d
      ```
      
      ## Reload Nginx
      
      After adding/modifying configs:
      ```bash
      docker exec nginx nginx -s reload
      ```
      
      ## View Nginx Logs
      ```bash
      docker logs nginx
      docker logs -f nginx  # Follow logs
      ```
      
      ## Test Configuration
      ```bash
      docker exec nginx nginx -t
      ```
    permissions: '0644'

runcmd:
  # Install Docker
  - curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
  - echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
  - apt-get update
  - apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
  - systemctl enable docker
  - systemctl start docker
  - usermod -aG docker azureuser
  
  # Create Docker network for services
  - docker network create --driver bridge app-network
  
  # Create Nginx config directory
  - mkdir -p /opt/nginx/conf.d
  
  # Run Nginx as Docker container
  - |
    docker run -d \
      --name nginx \
      --network app-network \
      -p 80:80 \
      -p 443:443 \
      -v /opt/nginx/default.conf:/etc/nginx/conf.d/default.conf:ro \
      -v /opt/nginx/conf.d:/etc/nginx/conf.d/services:ro \
      --restart unless-stopped \
      nginx:alpine
  
  # Install GitHub Actions Runner
  - mkdir -p /opt/actions-runner
  - cd /opt/actions-runner
  - curl -o actions-runner-linux-x64.tar.gz -L https://github.com/actions/runner/releases/download/v2.311.0/actions-runner-linux-x64-2.311.0.tar.gz
  - tar xzf actions-runner-linux-x64.tar.gz
  - chown -R azureuser:azureuser /opt/actions-runner
  
  # Configure and start runner as azureuser
  - |
    sudo -u azureuser bash -c "cd /opt/actions-runner && ./config.sh --url ${github_repo_url} --token ${github_runner_token} --name ${github_runner_name} --labels ${github_runner_labels} --unattended --replace"
  - cd /opt/actions-runner
  - ./svc.sh install azureuser
  - ./svc.sh start
  
  # Setup log rotation
  - |
    cat > /etc/logrotate.d/github-runner <<EOF
    /opt/actions-runner/_diag/*.log {
        daily
        rotate 7
        compress
        missingok
        notifempty
    }
    EOF

final_message: "GitHub Actions runner setup complete after $UPTIME seconds"
