#cloud-config
package_update: true
package_upgrade: true

packages:
  - apt-transport-https
  - ca-certificates
  - curl
  - gnupg
  - lsb-release
  - software-properties-common
  - jq
  - unzip
  - nginx

write_files:
  - path: /opt/setup-complete.flag
    content: |
      Setup initiated at $(date)
    permissions: '0644'

runcmd:
  # Install Docker
  - curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
  - echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
  - apt-get update
  - apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
  - systemctl enable docker
  - systemctl start docker
  - usermod -aG docker azureuser
  
  # Create Docker network for services
  - docker network create --driver bridge app-network
  
  # Configure Native Nginx
  - mkdir -p /etc/nginx/conf.d/auto-generated
  - mkdir -p /var/log/nginx
  - touch /etc/nginx/conf.d/auto-generated/upstreams.conf
  - touch /etc/nginx/conf.d/auto-generated/locations.conf
  
  # Create main Nginx configuration
  - |
    cat > /etc/nginx/nginx.conf <<'EOF'
    user www-data;
    worker_processes auto;
    pid /run/nginx.pid;
    error_log /var/log/nginx/error.log;

    events {
        worker_connections 1024;
    }

    http {
        include /etc/nginx/mime.types;
        default_type application/octet-stream;

        log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                        '$status $body_bytes_sent "$http_referer" '
                        '"$http_user_agent" "$http_x_forwarded_for"';

        access_log /var/log/nginx/access.log main;

        sendfile on;
        tcp_nopush on;
        keepalive_timeout 65;
        gzip on;

        # Default server
        server {
            listen 80 default_server;
            server_name _;

            # Health check endpoint
            location /health {
                access_log off;
                return 200 "Nginx reverse proxy is running\n";
                add_header Content-Type text/plain;
            }
            
            # Include auto-generated container locations
            include /etc/nginx/conf.d/auto-generated/locations.conf;

            # Default response
            location / {
                return 200 "Nginx is running. Application routes will be auto-configured.\n";
                add_header Content-Type text/plain;
            }
        }

        # Include upstreams
        include /etc/nginx/conf.d/auto-generated/upstreams.conf;
    }
    EOF
  
  - systemctl enable nginx
  - systemctl start nginx
  
  # Create automated Nginx configuration manager script
  - |
    cat > /usr/local/bin/nginx-auto-config.sh <<'AUTOCONFIG'
    #!/bin/bash
    # Automated Nginx Configuration Manager for Native Nginx
    LOG_FILE="/var/log/nginx-auto-config.log"
    CONFIG_DIR="/etc/nginx/conf.d/auto-generated"
    mkdir -p $CONFIG_DIR

    log() {
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
    }

    # Collect container info and store in temp file
    collect_container_info() {
        local container_id=$1
        local container_name=$(docker inspect --format='{{.Name}}' $container_id | sed 's/^\///')
        
        # Get container IP from app-network using jq for reliability
        local container_ip=$(docker inspect $container_id | jq -r '.[0].NetworkSettings.Networks["app-network"].IPAddress // empty' 2>/dev/null)
        
        if [ -z "$container_ip" ]; then
            log "Container $container_name not on app-network, skipping"
            return
        fi
        
        # Get labels
        local nginx_enable=$(docker inspect --format='{{index .Config.Labels "nginx.enable"}}' $container_id)
        local nginx_path=$(docker inspect --format='{{index .Config.Labels "nginx.path"}}' $container_id)
        local nginx_port=$(docker inspect --format='{{index .Config.Labels "nginx.port"}}' $container_id)
        
        # Skip if disabled
        if [ "$nginx_enable" == "false" ]; then
            log "Container $container_name has nginx.enable=false, skipping"
            return
        fi
        
        # Require nginx.path label
        if [ -z "$nginx_path" ] || [ "$nginx_path" == "<no value>" ]; then
            log "No nginx.path label for $container_name, skipping"
            return
        fi
        
        # Get internal container port (not host port)
        if [ -z "$nginx_port" ] || [ "$nginx_port" == "<no value>" ]; then
            # Auto-detect internal port from exposed ports
            nginx_port=$(docker inspect --format='{{range $key, $value := .Config.ExposedPorts}}{{$key}}{{end}}' $container_id | cut -d'/' -f1 | head -n1)
        fi
        
        if [ -z "$nginx_port" ]; then
            log "Could not determine port for $container_name, skipping"
            return
        fi
        
        log "Found container: $container_name at $container_ip:$nginx_port path $nginx_path"
        
        # Store info in temp file
        echo "$container_name|$container_ip|$nginx_port|$nginx_path" >> /tmp/nginx-containers.tmp
    }

    # Generate consolidated nginx config from all collected containers
    generate_consolidated_config() {
        local temp_file="/tmp/nginx-containers.tmp"
        
        if [ ! -f "$temp_file" ] || [ ! -s "$temp_file" ]; then
            log "No containers to configure"
            return
        fi
        
        log "Generating consolidated nginx configuration..."
        
        # Generate upstreams file
        local upstream_file="$CONFIG_DIR/upstreams.conf"
        echo "# Auto-generated upstreams - $(date)" > $upstream_file
        
        while IFS='|' read -r name ip port path; do
            cat >> $upstream_file <<UPSTREAM
    upstream $${name}_backend {
        server $${ip}:$${port};
        keepalive 32;
    }
    UPSTREAM
        done < $temp_file
        
        # Generate locations file
        local locations_file="$CONFIG_DIR/locations.conf"
        echo "# Auto-generated locations - $(date)" > $locations_file
        echo "# These locations are included in the main server block" >> $locations_file
        
        while IFS='|' read -r name ip port path; do
            # Add trailing slash to path for proper matching
            local path_prefix="$path"
            [ "$path" != "/" ] && path_prefix="$${path}/"
            
            cat >> $locations_file <<LOCATION

    location $path_prefix {
        rewrite ^$path/(.*) /\$1 break;
        proxy_pass http://$${name}_backend;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    LOCATION
        done < $temp_file
        
        # Test and reload
        log "Testing nginx configuration..."
        if nginx -t 2>&1 | tee -a $LOG_FILE; then
            systemctl reload nginx 2>&1 | tee -a $LOG_FILE
            log "✅ Consolidated config created and loaded"
            log "   Upstreams: $upstream_file"
            log "   Locations: $locations_file"
        else
            log "❌ Nginx config test failed!"
            rm -f $upstream_file $locations_file
        fi
        
        # Cleanup temp file
        rm -f $temp_file
    }

    rebuild_all_configs() {
        log "Rebuilding all container configurations..."
        
        # Clear temp file
        rm -f /tmp/nginx-containers.tmp
        
        # Collect all containers on app-network
        docker ps --filter "network=app-network" --format '{{.ID}}' | while read cid; do
            collect_container_info $cid
        done
        
        # Generate consolidated config
        generate_consolidated_config
    }

    # Initialize with existing containers
    log "Initializing: scanning existing containers on app-network..."
    rebuild_all_configs

    # Monitor Docker events
    log "Monitoring Docker events..."
    docker events --filter 'type=container' --filter 'event=start' --filter 'event=die' --format '{{json .}}' | while read event; do
        event_type=$(echo $event | jq -r '.status')
        container_name=$(echo $event | jq -r '.Actor.Attributes.name')
        
        log "Event: $event_type for $container_name"
        
        # Always rebuild all configs on any container change
        # This ensures consistency and handles multi-container scenarios
        sleep 2  # Brief delay to ensure container is fully started/stopped
        rebuild_all_configs
    done
    AUTOCONFIG
  
  - chmod +x /usr/local/bin/nginx-auto-config.sh
  
  # Create systemd service for auto-config
  - |
    cat > /etc/systemd/system/nginx-auto-config.service <<'SYSTEMD'
    [Unit]
    Description=Nginx Auto Configuration Manager
    After=docker.service nginx.service
    Requires=docker.service nginx.service
    
    [Service]
    Type=simple
    User=root
    ExecStart=/usr/local/bin/nginx-auto-config.sh
    Restart=always
    RestartSec=10
    StandardOutput=append:/var/log/nginx-auto-config.log
    StandardError=append:/var/log/nginx-auto-config.log
    
    [Install]
    WantedBy=multi-user.target
    SYSTEMD
  
  - systemctl daemon-reload
  - systemctl enable nginx-auto-config.service
  - systemctl start nginx-auto-config.service
  
  # Install GitHub Actions Runner
  - mkdir -p /opt/actions-runner
  - cd /opt/actions-runner
  - curl -o actions-runner-linux-x64.tar.gz -L https://github.com/actions/runner/releases/download/v2.311.0/actions-runner-linux-x64-2.311.0.tar.gz
  - tar xzf actions-runner-linux-x64.tar.gz
  - chown -R azureuser:azureuser /opt/actions-runner
  
  # Configure and start runner as azureuser
  - |
    sudo -u azureuser bash -c "cd /opt/actions-runner && ./config.sh --url ${github_repo_url} --token ${github_runner_token} --name ${github_runner_name} --labels ${github_runner_labels} --unattended --replace"
  - cd /opt/actions-runner
  - ./svc.sh install azureuser
  
  # Add runner user to docker group and restart service
  - usermod -aG docker azureuser
  - |
    if systemctl is-active --quiet actions.runner.* 2>/dev/null; then
      systemctl restart actions.runner.*.service
      echo "GitHub Actions runner service restarted with docker group access"
    fi
  
  - ./svc.sh start
  
  # Setup log rotation
  - |
    cat > /etc/logrotate.d/github-runner <<EOF
    /opt/actions-runner/_diag/*.log {
        daily
        rotate 7
        compress
        missingok
        notifempty
    }
    EOF

final_message: "GitHub Actions runner setup complete after $UPTIME seconds"
